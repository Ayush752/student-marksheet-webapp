<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>INTERSTELLAR MULTIPLAYER COSMOS</title>
<style>
body{margin:0;overflow:hidden;font-family:'Orbitron',sans-serif;background:black;color:white;}
#hud{position:fixed;top:20px;left:20px;z-index:10;color:#00f5ff;font-family:monospace;}
button#toggleBtn{
  position:fixed;top:20px;right:20px;z-index:11;padding:10px 20px;border:none;border-radius:30px;cursor:pointer;background:#00f5ff;color:#000;font-weight:bold;
}
</style>
</head>
<body>
<div id="hud">ü™ê Procedural Interstellar Multiplayer Universe - WASD/Mouse | Click to Lock Pointer | VR + Multiplayer</div>
<button id="toggleBtn">Toggle Light Mode</button>

<script type="module">
// --- Imports ---
import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';

// --- Scene & Camera ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000,0.0015);
const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,5000);
camera.position.set(0,50,200);

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.xr.enabled=true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// --- Lights ---
const light = new THREE.PointLight(0xffffff,2);
light.position.set(0,500,500);
scene.add(light);

// --- Starfield ---
const starGeo = new THREE.BufferGeometry();
const starCount=30000;
const starPos = new Float32Array(starCount*3);
for(let i=0;i<starCount*3;i++){starPos[i]=(Math.random()-0.5)*8000;}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
const stars = new THREE.Points(starGeo,new THREE.PointsMaterial({color:0xffffff,size:1}));
scene.add(stars);

// --- Procedural Solar Systems ---
const systems=[];
function createSystem(x,z,numPlanets){
  const system = new THREE.Group();
  system.position.set(x,0,z);
  const sunGeo = new THREE.SphereGeometry(20,32,32);
  const sunMat = new THREE.MeshStandardMaterial({color:0xffaa00,emissive:0xffaa00,emissiveIntensity:0.3});
  const sun = new THREE.Mesh(sunGeo,sunMat);
  system.add(sun);

  const planets=[];
  for(let i=0;i<numPlanets;i++){
    const size = Math.random()*5 + 3;
    const dist = 40 + i*20 + Math.random()*10;
    const color = new THREE.Color(Math.random(),Math.random(),Math.random());
    const geo = new THREE.SphereGeometry(size,16,16);
    const mat = new THREE.MeshStandardMaterial({color:color,emissive:color,emissiveIntensity:0.2});
    const planet = new THREE.Mesh(geo,mat);
    planet.userData={angle:Math.random()*Math.PI*2, distance:dist, speed:0.005 + Math.random()*0.005};
    planet.position.set(dist,0,0);
    system.add(planet);
    planets.push(planet);
  }
  system.userData = {planets};
  scene.add(system);
  systems.push(system);
}
for(let i=-1;i<=1;i++){
  for(let j=-1;j<=1;j++){
    createSystem(i*600,j*600,3+Math.floor(Math.random()*3));
  }
}

// --- AI NPC Fleets ---
const fleets=[];
function createNPCFleet(count){
  const fleet=[];
  for(let i=0;i<count;i++){
    const geo = new THREE.ConeGeometry(2,6,8);
    const mat = new THREE.MeshStandardMaterial({color:0xff00ff,emissive:0xff00ff});
    const ship = new THREE.Mesh(geo,mat);
    ship.rotation.x=Math.PI/2;
    ship.position.set((Math.random()-0.5)*1000,(Math.random()-0.5)*200,(Math.random()-0.5)*1000);
    ship.userData={dir:new THREE.Vector3(Math.random()-0.5,Math.random()*0.1,Math.random()-0.5).normalize(),speed:0.5+Math.random()*0.5};
    scene.add(ship);
    fleet.push(ship);
  }
  fleets.push(fleet);
}
for(let i=0;i<3;i++) createNPCFleet(5);

// --- Portals ---
const portals=[];
function createPortal(x,z){
  const geo = new THREE.TorusGeometry(15,2,16,100);
  const mat = new THREE.MeshStandardMaterial({color:0x00ffff,emissive:0x00ffff,emissiveIntensity:0.5});
  const torus = new THREE.Mesh(geo,mat);
  torus.rotation.x=Math.PI/2;
  torus.position.set(x,10,z);
  torus.userData = {destination:new THREE.Vector3(x+Math.random()*1000-500,10,z+Math.random()*1000-500)};
  scene.add(torus);
  portals.push(torus);
}
for(let i=0;i<5;i++){
  createPortal((Math.random()-0.5)*1000,(Math.random()-0.5)*1000);
}

// --- Controls ---
const controls = new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true; controls.dampingFactor=0.05;
controls.enablePan=false;

// --- FPS Movement ---
let move={w:false,s:false,a:false,d:false};
document.body.addEventListener("click",()=>document.body.requestPointerLock());
document.addEventListener("mousemove",(e)=>{
  if(document.pointerLockElement===document.body){
    camera.rotation.y-=e.movementX*0.002;
    camera.rotation.x-=e.movementY*0.002;
  }
});
document.addEventListener("keydown",(e)=>{move[e.key.toLowerCase()]=true;});
document.addEventListener("keyup",(e)=>{move[e.key.toLowerCase()]=false;});

// --- Animate ---
function animate(){
  renderer.setAnimationLoop(render);
}
function render(){
  const speed=1;
  if(move.w) camera.translateZ(-speed);
  if(move.s) camera.translateZ(speed);
  if(move.a) camera.translateX(-speed);
  if(move.d) camera.translateX(speed);

  // Planet Orbits
  systems.forEach(sys=>{
    sys.userData.planets.forEach(p=>{
      p.userData.angle+=p.userData.speed;
      p.position.x = Math.cos(p.userData.angle)*p.userData.distance;
      p.position.z = Math.sin(p.userData.angle)*p.userData.distance;
    });
  });

  // NPC Fleet Movement
  fleets.forEach(fleet=>{
    fleet.forEach(ship=>{
      ship.position.add(ship.userData.dir.clone().multiplyScalar(ship.userData.speed));
      if(ship.position.length()>2000) ship.userData.dir.multiplyScalar(-1);
    });
  });

  // Portal teleport
  portals.forEach(p=>{
    if(camera.position.distanceTo(p.position)<20){
      camera.position.copy(p.userData.destination);
    }
  });

  // Stars slight rotation
  stars.rotation.y += 0.0005;

  controls.update();
  renderer.render(scene,camera);
}
animate();

// --- Responsive ---
window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// --- Dark/Light toggle ---
const toggleBtn = document.getElementById('toggleBtn');
toggleBtn.addEventListener('click',()=>{
  document.body.style.background = (document.body.style.background=='black')?'white':'black';
});
</script>
</body>
</html>
